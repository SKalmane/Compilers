			Last revised 13-Feb-15

			    Problem Set 6

		 Harvard Extension School CSCI E-95:
	   Compiler Design and Implementation - Spring 2015

		     Due: Midnight on May 3, 2015

1. (100 Points) Based on all the work you have completed so far, your
lexer from Problem Set 1, your recursive descent, YACC, or Bison
parser from Problem Set 2, your symbol table management system from
Problem Set 3, the type checker from Problem Set 4, and the
intermediate code generator from Problem Set 5, develop code to
traverse the intermediate code linked list and generate MIPS assembly
language acceptable to SPIM.

The input to Problem Set 6 is the linked list of intermediate code
(IR) in the three-address representation we discussed in class.  The
output is a file containing MIPS assembly language statements as
accepted by the SPIM interpreter which is available over the Web.  The
generation of MIPS assembly language should be performed in a
straight-forward manner.  Generate good code, but do not attempt to
perform any optimization.  Each IR node should generate assembly
statements -- do not attempt to generate code based on a sequence of
IR nodes.  Feel free to use labels in the MIPS code you generate --
the labels may be used as targets of branches (in which case they
would be automatically generated by the code generation module of your
compiler) or the labels may be used for static global variables (in
which case they might be the same as the names declared in the source
file being compiled -- possibly with a prefix to avoid any duplication
of labels).

Code generation for calling functions and returning from functions and
for access to local variables should use the stack frames and calling
conventions that we discussed in class.  Local variables should be
allocated on the stack and accessed through the frame pointer,
register $fp ($30).  Parameters and return values can either be passed
and returned, respectively, either through registers or on the stack
-- this is a decision we are leaving to your implementation.
Obviously, if there are too many parameters, at least the excess
parameters will need to be passed on the stack.

When you first attempt to generate code, try to compile only very
small programs using the temporaries in the IR nodes as actual
registers.  Obviously, this will work only when there are no more
temporaries than actual registers.  After this is working, write code
to reset the register generated for temporaries at the start of each
language construct across which temporaries are not used (for example,
this might be at the start of each statement).  After this is working,
you may attempt to write a module to perform register allocation based
on the graph coloring algorithm discussed in class and in the textbook
(Aho, Lam, Sethi, Ullman on pages 556-557).

You may want to incorporate built-in pre-defined functions that map
directly to the system calls provided by SPIM (such as print_int,
print_string, read_int, read_string, and exit).

Your problem set solution should include the source program to your
compiler, the output from the previous compiler stages, a printout of
the MIPS code produced by this code generation component, and a
transcript of running the MIPS code under SPIM.

As always, the solution that you turn in should include a
demonstration that your program works and has been tested.  Thus, the
test programs you use as input and the output that your compiler
produces should be included with your other files.
